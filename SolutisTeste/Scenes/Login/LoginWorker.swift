//
//  LoginWorker.swift
//  SolutisTeste
//
//  Created by Virtual Machine on 16/09/21.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import SVProgressHUD
import KeychainAccess
import LocalAuthentication

enum LoginWorkerErrors: String, Error {
    case invalidEmail = "Email inválido"
    case invalidPassword = "Senha inválida"
    case swtEmailError = "Caso não queria salvar o email desabilite a opção Habilitar Biometria antes do Salvar email"
    case biometricError = "Falha ao autenticar Por favor tente novamente"
    case biometricUnavailable = "Desculpe está feature esta indisponível para este aparelho, Porfavor habilite nas configurações"
}

protocol LoginWorkerProtocol {
    func doLogin(_ user: UserLogin, _ swtEmail: Bool, _ swtBiometric: Bool, completionHandler: @escaping(Result<UserData, Error>) -> Void)
    func keyChainVerification(_ swtLogin: Bool, _ swtBiometric: Bool, completionHandler: @escaping(Result<UserLogin, Error>) -> Void)
    func swtVerifications(type: String, swtEmail: Bool, swtBiometric: Bool, completionHandler: @escaping (Result<String, Error>) -> Void)
    func biometricVerification(context: LAContext,completionHandler: @escaping (Result<UserLogin, Error>) -> Void)
    func keyChainLoad(swtEmail: Bool, swtBiometric: Bool) -> UserLogin
    func keyChainSave(username: String?, password: String?)
}

extension LoginWorkerErrors: LocalizedError{
    var errorDescription: String? {return NSLocalizedString(rawValue, comment: "")}
}

class LoginWorker: LoginWorkerProtocol {
    
    let apiRequester: APIRequestProtocol
    let utils: UtilsProtocol
    
    init(apiRequester: APIRequestProtocol, utils: UtilsProtocol) {
        self.apiRequester = apiRequester
        self.utils = utils
    }
    
    //MARK:- API Call
    func doLogin(_ user: UserLogin, _ swtEmail: Bool, _ swtBiometric: Bool, completionHandler: @escaping(Result<UserData, Error>) -> Void) {
        
        if (utils.isValidEmail(email: user.login) == false) {
            completionHandler(.failure(LoginWorkerErrors.invalidEmail))
            return
        }
        
        if (utils.isValidPassword(password: user.password) == false) {
            completionHandler(.failure(LoginWorkerErrors.invalidPassword))
            return
        }
        
        SVProgressHUD.show()
        
        apiRequester.doLogin(user.login, user.password) { result in
            switch result {
            case .success(_):
                if swtEmail == true && swtBiometric == true {
                    self.keyChainSave(username: user.login , password: user.password)
                }else if swtEmail == true && swtBiometric == false {
                    self.keyChainSave(username: user.login , password: nil)
                }else {
                    self.keyChainSave(username: nil , password: nil)
                }
                
                break
            
            case .failure(_):
                break
            }
            completionHandler(result)
            return
        }
    }
    
    //MARK:- KeyChain Load data and swtVerification
    
    func keyChainVerification(_ swtLogin: Bool, _ swtBiometric: Bool, completionHandler: @escaping(Result<UserLogin, Error>) -> Void) {
        
        completionHandler(.success(keyChainLoad(swtEmail: swtLogin, swtBiometric: swtBiometric)))
        
    }
    
    
    func swtVerifications(type: String, swtEmail: Bool, swtBiometric: Bool, completionHandler: @escaping (Result<String, Error>) -> Void) {
        var message = "A biometria estará ativa na proxima tentativa de login"
        if(swtEmail == false && swtBiometric == true) {
            if (type == "Email") {
                completionHandler(.failure(LoginWorkerErrors.swtEmailError))
                return
            }else{
                message = "A biometria estará ativa na proxima tentativa de login"
                completionHandler(.success(message))
                return
            }
        }else if(swtBiometric == true){
            message = "A biometria estará ativa na proxima tentativa de login"
            completionHandler(.success(message))
            return
        }
        
    }

    
}

    // MARK:- Biometric And FaceID
extension LoginWorker {
    func biometricVerification(context: LAContext,completionHandler: @escaping (Result<UserLogin, Error>) -> Void){
        var error: NSError? = nil
        if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error){
            let reason = "Porfavor autorize com a biometria!"
            context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) {
                sucess, error in

                guard sucess, error == nil else{
                    completionHandler(.failure(LoginWorkerErrors.biometricError))
                    return
                }
                
                let userLogin = self.keyChainLoad(swtEmail: true, swtBiometric: true)
                completionHandler(.success(userLogin))
                return
            }
        } else {
            completionHandler(.failure(LoginWorkerErrors.biometricUnavailable))
            return
        }
    }
}

    // MARK:- KeyChain Functions
extension LoginWorker {
    func keyChainSave(username: String?, password: String?){
        let keychain = Keychain(service: "com.roberto.SolutisTeste")
        keychain["username"] = username
        keychain["password"] = password
    }
    
    func keyChainLoad(swtEmail: Bool, swtBiometric: Bool) -> UserLogin {
        let keychain = Keychain(service: "com.roberto.SolutisTeste")
        let username = keychain["username"]
        let password = keychain["password"]
        let userLogin = UserLogin(login: username ?? "", password: password ?? "")
        return userLogin
    }
}



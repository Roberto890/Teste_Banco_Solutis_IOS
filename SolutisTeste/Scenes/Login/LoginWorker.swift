//
//  LoginWorker.swift
//  SolutisTeste
//
//  Created by Virtual Machine on 16/09/21.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import SVProgressHUD
import KeychainAccess
import LocalAuthentication

enum LoginWorkerErrors: String, Error {
    case invalidEmail = "Email inválido"
    case invalidPassword = "Senha inválida"
    case swtEmailError = "Caso não queria salvar o email desabilite a opção Habilitar Biometria antes do Salvar email"
    case biometricError = "Falha ao autenticar Por favor tente novamente"
    case biometricUnavailable = "Desculpe está feature esta indisponível para este aparelho, Porfavor habilite nas configurações"
}

extension LoginWorkerErrors: LocalizedError{
    var errorDescription: String? {return NSLocalizedString(rawValue, comment: "")}
}

class LoginWorker {
    
    func doLogin(_ user: UserLogin, _ swtEmail: Bool, _ swtBiometric: Bool, completionHandler: @escaping(Result<UserData, Error>) -> Void) {
        
        let utils = Utils()
        
        if (!utils.isValidEmail(email: user.login)) {
            completionHandler(.failure(LoginWorkerErrors.invalidEmail))
            return
        }
        
        if (!utils.isValidPassword(password: user.password)) {
            completionHandler(.failure(LoginWorkerErrors.invalidPassword))
            return
        }
        
        SVProgressHUD.show()
        
        APIRequest().doLogin(user.login, user.password) { result in
            switch result {
            case .success(_):
                if swtEmail == true && swtBiometric == true {
                    self.keyChainSave(username: user.login , password: user.password)
                }else if swtEmail == true && swtBiometric == false {
                    self.keyChainSave(username: user.login , password: nil)
                }else {
                    self.keyChainSave(username: nil , password: nil)
                }
                
                break
            
            case .failure(_):
                break
            }
            completionHandler(result)
            return
        }
    }
    
    func keyChainVerification(_ swtLogin: Bool, _ swtBiometric: Bool, completionHandler: @escaping(Result<UserLogin, Error>) -> Void) {
        
        completionHandler(.success(keyChainLoad(swtEmail: swtLogin, swtBiometric: swtBiometric)))
        
    }
    
    
    func swtVerifications(type: String, swtEmail: Bool, swtBiometric: Bool, completionHandler: @escaping (Result<String, Error>) -> Void) {
        var message = "A biometria estará ativa na proxima tentativa de login"
        if(swtEmail == false && swtBiometric == true) {
            if (type == "Email") {
                completionHandler(.failure(LoginWorkerErrors.swtEmailError))
                return
            }else{
                message = "A biometria estará ativa na proxima tentativa de login"
                completionHandler(.success(message))
                return
            }
        }else if(swtBiometric == true){
            message = "A biometria estará ativa na proxima tentativa de login"
            completionHandler(.success(message))
            return
        }
        
    }

    
}

// MARK:- Biometric And FaceID
extension LoginWorker {
    func biometricVerification(completionHandler: @escaping (Result<UserLogin, Error>) -> Void){
        let context = LAContext()
        var error: NSError? = nil
        if context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error){
            let reason = "Porfavor autorize com a biometria!"
            context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: reason) {
                sucess, error in

                guard sucess, error == nil else{
                    completionHandler(.failure(LoginWorkerErrors.biometricError))
                    return
                }
                
                let userLogin = self.keyChainLoad(swtEmail: true, swtBiometric: true)
                completionHandler(.success(userLogin))
                return
            }
        } else {
            
            completionHandler(.failure(LoginWorkerErrors.biometricUnavailable))
            return
//            let alert = UIAlertController(title: "FaceID ou Biometria", message: "Desculpe está feature esta indisponível para este aparelho, Porfavor habilite nas configurações", preferredStyle: .alert)
//            alert.addAction(UIAlertAction(title: "Cancelar", style: .cancel, handler: nil))
//            present(alert, animated: true, completion: nil)
//            swtBiometric.isOn = false


        }
    }
}

// MARK:- KeyChain Functions
private extension LoginWorker {
    func keyChainSave(username: String?, password: String?){
        let keychain = Keychain(service: "com.roberto.SolutisTeste")
        keychain["username"] = username
        keychain["password"] = password
    }
    
    func keyChainLoad(swtEmail: Bool, swtBiometric: Bool) -> UserLogin {
        let keychain = Keychain(service: "com.roberto.SolutisTeste")
        let username = keychain["username"]
        let password = keychain["password"]
        let userLogin = UserLogin(login: username ?? "", password: password ?? "")
        return userLogin
    }
}


